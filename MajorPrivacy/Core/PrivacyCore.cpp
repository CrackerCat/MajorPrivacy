#include "pch.h"
#include "PrivacyCore.h"
#include "Processes/ProcessList.h"
#include "Processes/EnclaveList.h"
#include "Processes/ExecLogEntry.h"
#include "Programs/ProgramManager.h"
#include "Network/NetworkManager.h"
#include "Network/NetLogEntry.h"
#include "Volumes/VolumeManager.h"
#include "Tweaks/TweakManager.h"
#include "../Library/Common/Exception.h"
#include "Access/ResLogEntry.h"
#include "Access/AccessManager.h"

#include <phnt_windows.h>
#include <phnt.h>

#include "../Library/Helpers/AppUtil.h"
#include "../Library/API/PrivacyAPI.h"
#include "../Library/API/PrivacyAPI.h"

#ifdef _DEBUG
#include "../Library/Crypto/Encryption.h"
#include "../Library/Crypto/PrivateKey.h"
#include "../Library/Crypto/PublicKey.h"
#endif

CSettings* theConf = NULL;
CPrivacyCore* theCore = NULL;

#ifdef _DEBUG
void XVariantTest();
#endif

CPrivacyCore::CPrivacyCore(QObject* parent)
: QObject(parent), m_Driver(CDriverAPI::eDevice)
{
#ifdef _DEBUG
	XVariantTest();

	/*NTSTATUS Status;
	CBuffer Text1((void*)"Hello, World 123Hello, World", 28, true);
	CBuffer Key((void*)"1234567890abcdef", 16, true);
	CBuffer CipherText;
	CBuffer Text2;

	CEncryption Encryption;
	Status = Encryption.SetPassword(CBuffer("1234567890", 10, true));

	Status = Encryption.Encrypt(Text1, CipherText);
	Status = Encryption.Decrypt(CipherText, Text2);

	CPrivateKey PrivateKey;
	CPublicKey PublicKey;
	PrivateKey.MakeKeyPair(PublicKey);

	CBuffer Hash((void*)"Hello, World 123", 16, true);
	CBuffer Signature;
	Status = PrivateKey.Sign(Hash, Signature);
	Status = PublicKey.Verify(Hash, Signature);*/

#endif
	
	m_pProcessList = new CProcessList(this);
	m_pEnclaveList = new CEnclaveList(this);
	m_pProgramManager = new CProgramManager(this);
	m_pAccessManager = new CAccessManager(this);

	m_pNetworkManager = new CNetworkManager(this);

	m_pVolumeManager = new CVolumeManager(this);

	m_pTweakManager = new CTweakManager(this);

	//
	// Note trace log events always come from the service even though thay are generated by the driver 
	// Rule events are generated by the driver except for firewal
	// 
	// TODO: add own firewall engine to the driver
	//

	//m_Driver.RegisterRuleEventHandler(ERuleType::eAccess, &CPrivacyCore::OnDrvEvent, this);
	//m_Driver.RegisterRuleEventHandler(ERuleType::eProgram, &CPrivacyCore::OnDrvEvent, this);

	m_Service.RegisterEventHandler(SVC_API_EVENT_FW_RULE_CHANGED, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_EXEC_RULE_CHANGED, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_RES_RULE_CHANGED, &CPrivacyCore::OnSvcEvent, this);

	m_Service.RegisterEventHandler(SVC_API_EVENT_NET_ACTIVITY, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_EXEC_ACTIVITY, &CPrivacyCore::OnSvcEvent, this);
	m_Service.RegisterEventHandler(SVC_API_EVENT_RES_ACTIVITY, &CPrivacyCore::OnSvcEvent, this);
}

CPrivacyCore::~CPrivacyCore()
{
}

STATUS CPrivacyCore::Connect()
{
	STATUS Status;
#if 0
	if (IsRunningElevated()) {
		m_bEngineMode = true;
		Status = m_Service.ConnectEngine();
	}
	else { // todo: fix me add ability to install and start service as non admin !!!!!
		m_bEngineMode = false;
		Status = m_Service.ConnectSvc();
	}
#else
	m_bEngineMode = true;
	Status = m_Service.ConnectEngine();
#endif
	if (Status) {
		Status = m_Driver.ConnectDrv();
		if (Status) {
			m_Driver.RegisterForRuleEvents(ERuleType::eAccess);
			m_Driver.RegisterForRuleEvents(ERuleType::eProgram);
		}
	}
	return Status;
}

STATUS CPrivacyCore::Reconnect()
{
	STATUS Status = m_Service.Reconnect();
	if (Status) Status = m_Driver.Reconnect();
	return Status;
}

void CPrivacyCore::Disconnect(bool bKeepEngine)
{
	if (m_bEngineMode && !bKeepEngine)
		m_Service.Call(SVC_API_SHUTDOWN, CVariant());

	m_Service.Disconnect();
	m_Driver.Disconnect();

	m_ProgramRulesUpdated = false;
	m_AccessRulesUpdated = false;
	m_FwRulesUpdated = false;
}

STATUS CPrivacyCore::Update()
{
	STATUS Status;
	Status = m_pProcessList->Update(); if(!Status) return Status;
	Status = m_pEnclaveList->Update(); if(!Status) return Status;
	Status = m_pProgramManager->Update(); if(!Status) return Status;
	Status = m_pAccessManager->Update(); if(!Status) return Status;

	QMutexLocker Lock(&m_EventQueueMutex);
	//auto ProcRuleEvents = m_DrvEventQueue.take(ERuleType::eProgram);
	//auto ResRuleEvents = m_DrvEventQueue.take(ERuleType::eAccess);
	
	auto FwRuleEvents = m_SvcEventQueue.take(SVC_API_EVENT_FW_RULE_CHANGED);
	auto ExecRuleEvents = m_SvcEventQueue.take(SVC_API_EVENT_EXEC_RULE_CHANGED);
	auto ResRuleEvents = m_SvcEventQueue.take(SVC_API_EVENT_RES_RULE_CHANGED);

	auto NetEvents = m_SvcEventQueue.take(SVC_API_EVENT_NET_ACTIVITY);
	auto ExecEvents = m_SvcEventQueue.take(SVC_API_EVENT_EXEC_ACTIVITY);
	auto ResEvents = m_SvcEventQueue.take(SVC_API_EVENT_RES_ACTIVITY);
	Lock.unlock();

	//////////////////
	// Rules

	if (m_ProgramRulesUpdated)
	{
		//foreach(const SDrvRuleEvent& Event, ProcRuleEvents) {
		//  auto RuleId = Event.Guid;
		//	if (Event.Event == ERuleEvent::eRemoved)
		foreach(const XVariant& vEvent, ExecRuleEvents) {
			QString RuleId = vEvent[API_V_RULE_GUID].AsQStr();
			if (vEvent[API_V_EVENT].To<uint32>() == (uint32)ERuleEvent::eRemoved)
				m_pProgramManager->RemoveProgramRule(RuleId);
			else
				m_pProgramManager->UpdateProgramRule(RuleId);
		}
	}
	else if(m_pProgramManager->UpdateAllProgramRules())
		m_ProgramRulesUpdated = true;

	if (m_AccessRulesUpdated)
	{
		//foreach(const SDrvRuleEvent& Event, ResRuleEvents) {
		//  auto RuleId = Event.Guid;
		//	if (Event.Event == ERuleEvent::eRemoved)
		foreach(const XVariant& vEvent, ResRuleEvents) {
			QString RuleId = vEvent[API_V_RULE_GUID].AsQStr();
			if (vEvent[API_V_EVENT].To<uint32>() == (uint32)ERuleEvent::eRemoved)
				m_pAccessManager->RemoveAccessRule(RuleId);
			else
				m_pAccessManager->UpdateAccessRule(RuleId);
		}
	}
	else if(m_pAccessManager->UpdateAllAccessRules())
		m_AccessRulesUpdated = true;

	if (m_FwRulesUpdated) 
	{
		foreach(const XVariant& vEvent, FwRuleEvents) {
			QString RuleId = vEvent[API_V_RULE_GUID].AsQStr();
			if (vEvent[API_V_EVENT].To<uint32>() == (uint32)ERuleEvent::eRemoved)
				m_pNetworkManager->RemoveFwRule(RuleId);
			else
				m_pNetworkManager->UpdateFwRule(RuleId);
		}
	}
	else if(m_pNetworkManager->UpdateAllFwRules())
		m_FwRulesUpdated = true;

	//////////////////
	// Events

	foreach(const XVariant& Event, NetEvents)
	{
		//QJsonDocument doc(QJsonValue::fromVariant(Event.ToQVariant()).toObject());			
		//QByteArray data = doc.toJson();

		CProgramID ID;
		ID.FromVariant(Event[API_V_PROG_ID]);
		CProgramFilePtr pProgram = m_pProgramManager->GetProgramFile(ID.GetFilePath());
		if (!pProgram) continue;

		CNetLogEntry* pNetEnrty = new CNetLogEntry();
		CLogEntryPtr pEntry = CLogEntryPtr(pNetEnrty);
		pEntry->FromVariant(Event[API_V_EVENT_DATA]);
		pProgram->TraceLogAdd(ETraceLogs::eNetLog, pEntry, Event[API_V_EVENT_INDEX]);

		if (pNetEnrty->GetState() == EFwEventStates::UnRuled)
			emit UnruledFwEvent(pProgram, pEntry);
	}

	foreach(const XVariant& Event, ExecEvents)
	{
		CProgramID ID;
		ID.FromVariant(Event[API_V_PROG_ID]);
		CProgramFilePtr pProgram = m_pProgramManager->GetProgramFile(ID.GetFilePath());
		if (!pProgram) continue;

		CExecLogEntry* pExecEnrty = new CExecLogEntry();
		CLogEntryPtr pEntry = CLogEntryPtr(pExecEnrty);
		pEntry->FromVariant(Event[API_V_EVENT_DATA]);
		pProgram->TraceLogAdd(ETraceLogs::eExecLog, pEntry, Event[API_V_EVENT_INDEX]);

		switch (pExecEnrty->GetType())
		{
		case EExecLogType::eImageLoad:
			if (pExecEnrty->GetStatus() == EEventStatus::eBlocked)
				emit ExecutionEvent(pProgram, pEntry);
			break;
		case EExecLogType::eProcessStarted:
			if (pExecEnrty->GetRole() == EExecLogRole::eActor && pExecEnrty->GetStatus() == EEventStatus::eProtected)
				emit ExecutionEvent(pProgram, pEntry);
			break;
		}
	}

	foreach(const XVariant& Event, ResEvents)
	{
		CProgramID ID;
		ID.FromVariant(Event[API_V_PROG_ID]);
		CProgramFilePtr pProgram = m_pProgramManager->GetProgramFile(ID.GetFilePath());
		if (!pProgram) continue;

		CResLogEntry* pResEnrty = new CResLogEntry();
		CLogEntryPtr pEntry = CLogEntryPtr(pResEnrty);
		pEntry->FromVariant(Event[API_V_EVENT_DATA]);
		pProgram->TraceLogAdd(ETraceLogs::eResLog, pEntry, Event[API_V_EVENT_INDEX]);

		if(pResEnrty->GetStatus() == EEventStatus::eProtected)
			emit AccessEvent(pProgram, pEntry);
	}

	return OK;
}

void CPrivacyCore::OnSvcEvent(uint32 MessageId, const CBuffer* pEvent)
{
	// WARNING: this function is invoked from a worker thread !!!

	XVariant vEvent;
	try {
		vEvent.FromPacket(pEvent);
	}
	catch (const CException&)
	{
		ASSERT(0);
		return;
	}

	QMutexLocker Lock(&m_EventQueueMutex);
	m_SvcEventQueue[MessageId].enqueue(vEvent);
}

//void CPrivacyCore::OnDrvEvent(const std::wstring& Guid, ERuleEvent Event, ERuleType Type)
//{
//	// WARNING: this function is invoked from a worker thread !!!
//
//	QMutexLocker Lock(&m_EventQueueMutex);
//	m_DrvEventQueue[Type].enqueue(SDrvRuleEvent { QString::fromStdWString(Guid), Event });
//}

XVariant CPrivacyCore::MakeIDs(const QList<const class CProgramItem*>& Nodes)
{
	XVariant IDs;
	foreach(auto Item, Nodes) 
	{
		IDs.Append(Item->GetID().ToVariant(SVarWriteOpt()));
	}
	return IDs;
}

#define RET_AS_XVARIANT(r) \
auto Ret = r; \
if (Ret.IsError()) \
return ERR(Ret.GetStatus()); \
RETURN((XVariant&)Ret.GetValue());

#define RET_GET_XVARIANT(r, n) \
auto Ret = r; \
if (Ret.IsError()) \
return ERR(Ret.GetStatus()); \
CVariant& Res = Ret.GetValue(); \
RETURN((XVariant&)Res.Get(n));

QString CPrivacyCore::GetConfigDir()
{
	CVariant Request;
	auto Ret = m_Service.Call(SVC_API_GET_CONFIG_DIR, Request);
	if (Ret.IsError())
		return "";
	XVariant& Response = (XVariant&)Ret.GetValue();
	return Response[API_V_CONF_VALUE].AsQStr();
}

RESULT(XVariant) CPrivacyCore::GetConfig(const QString& Name) 
{
	CVariant Request;
	Request[API_V_CONF_KEY] = Name.toStdString();
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_CONFIG, Request), API_V_CONF_VALUE);
}

STATUS CPrivacyCore::SetConfig(const QString& Name, const XVariant& Value)
{
	CVariant Request;
	Request[API_V_CONF_KEY] = Name.toStdString();
	Request[API_V_CONF_VALUE] = Value;
	return m_Service.Call(SVC_API_SET_CONFIG, Request);
}

//RESULT(XVariant) CPrivacyCore::GetConfigMap(const XVariant& NameList)
//{
//	CVariant Request;
//	Request[API_V_CONF_MAP] = NameList;
//	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_CONFIG, Request), API_V_CONF_MAP);
//}
//
//STATUS CPrivacyCore::SetConfigMap(const XVariant& ValueMap)
//{
//	CVariant Request;
//	Request[API_V_CONF_MAP] = ValueMap;
//	return m_Service.Call(SVC_API_SET_CONFIG, Request);
//}

RESULT(XVariant) CPrivacyCore::GetSvcConfig()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_CONFIG, Request), API_V_CONF_DATA);
}

STATUS CPrivacyCore::SetSvcConfig(const XVariant& Data)
{
	CVariant Request;
	Request[API_V_CONF_DATA] = Data;
	return m_Service.Call(SVC_API_SET_CONFIG, Request);
}

RESULT(XVariant) CPrivacyCore::GetDrvConfig()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Driver.Call(API_GET_CONFIG_VALUE, Request), API_V_CONF_DATA);
}

STATUS CPrivacyCore::SetDrvConfig(const XVariant& Data)
{
	CVariant Request;
	Request[API_V_CONF_DATA] = Data;
	return m_Driver.Call(API_SET_CONFIG_VALUE, Request);
}

// Process Manager
RESULT(XVariant) CPrivacyCore::GetProcesses()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_PROCESSES, Request), API_V_PROCESSES);
}

RESULT(XVariant) CPrivacyCore::GetProcess(uint64 Pid)
{
	CVariant Request;
	Request[API_V_PID] = Pid;
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_PROCESS, Request))
}

RESULT(XVariant) CPrivacyCore::GetPrograms()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_PROGRAMS, Request), API_V_PROGRAMS);
}

RESULT(XVariant) CPrivacyCore::GetLibraries(uint64 CacheToken)
{
	CVariant Request;
	if(CacheToken != -1)
		Request[API_V_CACHE_TOKEN] = CacheToken;
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_LIBRARIES, Request));
}

STATUS CPrivacyCore::SetProgram(const CProgramItemPtr& pItem)
{
	return m_Service.Call(SVC_API_SET_PROGRAM, pItem->ToVariant(SVarWriteOpt()));
}

STATUS CPrivacyCore::RemoveProgramFrom(uint64 UID, uint64 ParentUID)
{
	CVariant Request;
	Request[API_V_PROG_UID] = UID;
	Request[API_V_PROG_PARENT] = ParentUID;
	return m_Service.Call(SVC_API_REMOVE_PROGRAM, Request);
}

STATUS CPrivacyCore::SetAllProgramRules(const XVariant& Rules)
{
	return m_Driver.Call(API_SET_PROGRAM_RULES, Rules);
}

RESULT(XVariant) CPrivacyCore::GetAllProgramRules()
{
	CVariant Request;
	RET_AS_XVARIANT(m_Driver.Call(API_GET_PROGRAM_RULES, Request));
}

STATUS CPrivacyCore::SetProgramRule(const XVariant& Rule)
{
	return m_Driver.Call(API_SET_PROGRAM_RULE, Rule);
}

RESULT(XVariant) CPrivacyCore::GetProgramRule(const QString& Name)
{
	CVariant Request;
	Request[API_V_RULE_GUID] = Name.toStdWString();
	RET_AS_XVARIANT(m_Driver.Call(API_GET_PROGRAM_RULE, Request));
}

STATUS CPrivacyCore::DelProgramRule(const QString& Name)
{
	CVariant Request;
	Request[API_V_RULE_GUID] = Name.toStdWString();
	return m_Driver.Call(API_DEL_PROGRAM_RULE, Request);
}

STATUS CPrivacyCore::StartProcessInEnvlave(const QString& Command, uint64 EnclaveId)
{
	XVariant Request;
	Request[API_V_COMMAND] = Command;
	Request[API_V_EID] = EnclaveId;
	return m_Service.Call(SVC_API_START_SECURE, Request);
}

// Access Manager
STATUS CPrivacyCore::SetAllAccessRules(const XVariant& Rules)
{
	return m_Driver.Call(API_SET_ACCESS_RULES, Rules);
}

RESULT(XVariant) CPrivacyCore::GetAllAccessRules()
{
	CVariant Request;
	RET_AS_XVARIANT(m_Driver.Call(API_GET_ACCESS_RULES, Request));
}

STATUS CPrivacyCore::SetAccessRule(const XVariant& Rule)
{
	return m_Driver.Call(API_SET_ACCESS_RULE, Rule);
}

RESULT(XVariant) CPrivacyCore::GetAccessRule(const QString& Name)
{
	CVariant Request;
	Request[API_V_RULE_GUID] = Name.toStdWString();
	RET_AS_XVARIANT(m_Driver.Call(API_GET_ACCESS_RULE, Request));
}

STATUS CPrivacyCore::DelAccessRule(const QString& Name)
{
	CVariant Request;
	Request[API_V_RULE_GUID] = Name.toStdWString();
	return m_Driver.Call(API_DEL_ACCESS_RULE, Request);
}

// Network Manager
RESULT(XVariant) CPrivacyCore::GetFwRulesFor(const QList<const class CProgramItem*>& Nodes)
{
	CVariant Request;
	if(!Nodes.isEmpty())
		Request[API_V_PROG_IDS] = MakeIDs(Nodes);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_FW_RULES, Request), API_V_FW_RULES);
}

RESULT(XVariant) CPrivacyCore::GetAllFwRules()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_FW_RULES, Request), API_V_FW_RULES);
}

STATUS CPrivacyCore::SetFwRule(const XVariant& FwRule)
{
	return m_Service.Call(SVC_API_SET_FW_RULE, FwRule);
}

RESULT(XVariant) CPrivacyCore::GetFwRule(const QString& Guid)
{
	CVariant Request;
	Request[API_V_RULE_GUID] = Guid.toStdWString();
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_FW_RULE, Request));
}

STATUS CPrivacyCore::DelFwRule(const QString& Guid)
{
	CVariant Request;
	Request[API_V_RULE_GUID] = Guid.toStdWString();
	return m_Service.Call(SVC_API_DEL_FW_RULE, Request);
}

RESULT(FwFilteringModes) CPrivacyCore::GetFwProfile()
{
	CVariant Request;
	auto Ret = m_Service.Call(SVC_API_GET_FW_PROFILE, Request);
	if (Ret.IsError())
		return Ret;
	CVariant& Response = Ret.GetValue();
	return (FwFilteringModes) Response.Get(API_V_FW_RULE_FILTER_MODE).To<uint32>();
}

STATUS CPrivacyCore::SetFwProfile(FwFilteringModes Profile)
{
	CVariant Request;
	Request[API_V_FW_RULE_FILTER_MODE] = (uint32)Profile;
	return m_Service.Call(SVC_API_SET_FW_PROFILE, Request);
}

RESULT(FwAuditPolicy) CPrivacyCore::GetAuditPolicy()
{
	CVariant Request;
	auto Ret = m_Service.Call(SVC_API_GET_FW_AUDIT_MODE, Request);
	if (Ret.IsError())
		return Ret;
	CVariant& Response = Ret.GetValue();
	return (FwAuditPolicy) Response.Get(API_V_FW_AUDIT_MODE).To<uint32>();
}

STATUS CPrivacyCore::SetAuditPolicy(FwAuditPolicy Profile)
{
	CVariant Request;
	Request[API_V_FW_AUDIT_MODE] = (uint32)Profile;
	return m_Service.Call(SVC_API_SET_FW_AUDIT_MODE, Request);
}

RESULT(XVariant) CPrivacyCore::GetSocketsFor(const QList<const class CProgramItem*>& Nodes)
{
	CVariant Request;
	if(!Nodes.isEmpty())
		Request[API_V_PROG_IDS] = MakeIDs(Nodes);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_SOCKETS, Request), API_V_SOCKETS);
}

RESULT(XVariant) CPrivacyCore::GetAllSockets()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_SOCKETS, Request), API_V_SOCKETS);
}

RESULT(XVariant) CPrivacyCore::GetTrafficLog(const class CProgramID& ID, quint64 MinLastActivity)
{
	CVariant Request;
	Request[API_V_PROG_ID] = ID.ToVariant(SVarWriteOpt());
	if(MinLastActivity) 
		Request[API_V_SOCK_LAST_ACT] = MinLastActivity;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_TRAFFIC, Request), API_V_NET_TRAFFIC);
}

RESULT(XVariant) CPrivacyCore::GetDnsCache()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_DNC_CACHE, Request), API_V_DNS_CACHE);
}

// Access Manager

RESULT(XVariant) CPrivacyCore::GetHandlesFor(const QList<const class CProgramItem*>& Nodes)
{
	CVariant Request;
	if(!Nodes.isEmpty())
		Request[API_V_PROG_IDS] = MakeIDs(Nodes);
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_HANDLES, Request), API_V_HANDLES);
}

RESULT(XVariant) CPrivacyCore::GetAllHandles()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_HANDLES, Request), API_V_HANDLES);
}

// Program Item
RESULT(XVariant) CPrivacyCore::GetLibraryStats(const class CProgramID& ID)
{
	CVariant Request;
	Request[API_V_PROG_ID] = ID.ToVariant(SVarWriteOpt());
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_LIBRARY_STATS, Request), API_V_LIBRARIES);
}

RESULT(XVariant) CPrivacyCore::GetExecStats(const class CProgramID& ID)
{
	CVariant Request;
	Request[API_V_PROG_ID] = ID.ToVariant(SVarWriteOpt());
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_EXEC_STATS, Request));
}

RESULT(XVariant) CPrivacyCore::GetIngressStats(const class CProgramID& ID)
{
	CVariant Request;
	Request[API_V_PROG_ID] = ID.ToVariant(SVarWriteOpt());
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_INGRESS_STATS, Request));
}

RESULT(XVariant) CPrivacyCore::GetAccessStats(const class CProgramID& ID, quint64 MinLastActivity)
{
	CVariant Request;
	Request[API_V_PROG_ID] = ID.ToVariant(SVarWriteOpt());
	if(MinLastActivity) 
		Request[API_V_SOCK_LAST_ACT] = MinLastActivity;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_ACCESS_STATS, Request), API_V_ROOT);
}

RESULT(XVariant) CPrivacyCore::GetTraceLog(const class CProgramID& ID, ETraceLogs Log)
{
	CVariant Request;
	Request[API_V_PROG_ID] = ID.ToVariant(SVarWriteOpt());
	Request[API_V_LOG_TYPE] = (uint32)Log;
	RET_AS_XVARIANT(m_Service.Call(SVC_API_GET_TRACE_LOG, Request));	
}

// Volume Manager
RESULT(XVariant) CPrivacyCore::GetVolumes()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_VOL_GET_ALL_VOLUMES, Request), API_V_VOLUMES);
}

STATUS CPrivacyCore::MountVolume(const QString& Path, const QString& MountPoint, const QString& Password)
{
	CVariant Request;
	Request[API_V_VOL_PATH] = QString(Path).replace("/","\\").toStdWString();
	Request[API_V_VOL_MOUNT_POINT] = MountPoint.toStdWString();
	Request[API_V_VOL_PASSWORD] = Password.toStdWString();
	return m_Service.Call(SVC_API_VOL_MOUNT_IMAGE, Request);
}

STATUS CPrivacyCore::DismountVolume(const QString& MountPoint)
{
	CVariant Request;
	Request[API_V_VOL_MOUNT_POINT] = MountPoint.toStdWString();
	return m_Service.Call(SVC_API_VOL_DISMOUNT_VOLUME, Request);
}

STATUS CPrivacyCore::DismountAllVolumes()
{
	CVariant Request;
	return m_Service.Call(SVC_API_VOL_DISMOUNT_ALL, Request);
}

STATUS CPrivacyCore::CreateVolume(const QString& Path, const QString& Password, quint64 ImageSize, const QString& Cipher)
{
	CVariant Request;
	Request[API_V_VOL_PATH] = QString(Path).replace("/","\\").toStdWString();
	Request[API_V_VOL_PASSWORD] = Password.toStdWString();
	if(ImageSize) Request[API_V_VOL_SIZE] = ImageSize;
	if(!Cipher.isEmpty()) Request[API_V_VOL_CIPHER] = Cipher.toStdWString();
	return m_Service.Call(SVC_API_VOL_CREATE_IMAGE, Request);
}

STATUS CPrivacyCore::ChangeVolumePassword(const QString& Path, const QString& OldPassword, const QString& NewPassword)
{
	CVariant Request;
	Request[API_V_VOL_PATH] = QString(Path).replace("/","\\").toStdWString();
	Request[API_V_VOL_OLD_PASS] = OldPassword.toStdWString();
	Request[API_V_VOL_NEW_PASS] = NewPassword.toStdWString();
	return m_Service.Call(SVC_API_VOL_CHANGE_PASSWORD, Request);
}

// Tweak Manager
RESULT(XVariant) CPrivacyCore::GetTweaks()
{
	CVariant Request;
	RET_GET_XVARIANT(m_Service.Call(SVC_API_GET_TWEAKS, Request), API_V_TWEAKS);
}

STATUS CPrivacyCore::ApplyTweak(const QString& Name)
{
	CVariant Request;
	Request[API_V_NAME] = Name.toStdWString();
	return m_Service.Call(SVC_API_APPLY_TWEAK, Request);
}

STATUS CPrivacyCore::UndoTweak(const QString& Name)
{
	CVariant Request;
	Request[API_V_NAME] = Name.toStdWString();
	return m_Service.Call(SVC_API_UNDO_TWEAK, Request);
}

//
STATUS CPrivacyCore::SetWatchedPrograms(const QSet<CProgramItemPtr>& Programs)
{
	XVariant ProgramList;
	ProgramList.BeginList();
	foreach(auto pProgram, Programs)
		ProgramList.Write(pProgram->GetUID());
	ProgramList.Finish();

	XVariant Request;
	Request[API_V_PROG_UIDS] = ProgramList;
	return m_Service.Call(SVC_API_SET_WATCHED_PROG, Request);
}

// Support
RESULT(XVariant) CPrivacyCore::GetSupportInfo()
{
	CVariant Request;
	RET_AS_XVARIANT(m_Driver.Call(API_GET_SUPPORT_INFO, Request));
}